This chapter describes a number of techniques for improving code performance. Ideally, a compiler would be able to take whatever code we write and generate the most efficient machine-level program possible. However, compilers are not perfect and programmers must assist by writing code that can be readily optimised.

In our presentation, we make code optimisation look like a simple linear process, applying a series of transformations in a particular order. This is a simplification;  a fair amount of trial-and-error experimentation is required. 

The contents of this chapter are:


* [Capabilities and Limitations of Optimising Compilers](Capabilities%20and%20Limitations%20of%20Optimising%20Compilers.md)
* [Expressing Program Performance](Expressing%20Program%20Performance.md)
* [Program Example](Program%20Example.md)
* [Eliminating Loop Inefficiencies](Eliminating%20Loop%20Inefficiencies.md)
* [Reducing Procedure Calls](Reducing%20Procedure%20Calls.md)
* [Eliminating Unneeded Memory References](Eliminating%20Unneeded%20Memory%20References.md)

> [!INFO]
> I Ankied up to here. The rest of the chapter is interesting, but a little dense and dry for me at the moment. Maybe I can come back round to it in the future.

* [Understanding Modern Processors](Understanding%20Modern%20Processors.md)
* [Loop Unrolling](Loop%20Unrolling)
* [Enhancing Parallelism](Enhancing%20Parallelism)
* [Summary of Results for Optimising Combining Code](Summary%20of%20Results%20for%20Optimising%20Combining%20Code)
* [Some Limiting Factors](Some%20Limiting%20Factors)
* [Understanding Memory Performance](Understanding%20Memory%20Performance)
* [Life in the Real World: Performance Improvement Techniques](Life%20in%20the%20Real%20World:%20Performance%20Improvement%20Techniques)
* [Identifying and Eliminating Performance Bottlenecks](Identifying%20and%20Eliminating%20Performance%20Bottlenecks)
